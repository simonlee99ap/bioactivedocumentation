<!DOCTYPE html>
<html>
<head>
	<title>BioActive</title>
	<link rel="stylesheet" type="text/css" href="../css/style.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css">
</head>
<body>
	<header id="main-header">
		<div class="container">
			<h1>BioActive</h1>
		</div>
	</header>

	<ul class="navbar">
		<li><a href="../index.html">Home</a></li>
		<li class="dropdown">
			<a href="javascript:void(0)" class="dropbtn">Campaigns</a>
			<div class="dropdown-content">
				<a href="../campaigns/battleship.html">Battleship</a>
				<a href="../campaigns/battleshipreal.html">BattleshipReal / Createplate</a>
				<a href="../campaigns/clustercampaign.html">ClusterCampaign</a>
				<a href="../campaigns/getdataimagecampaign.html">getDataImageCampaign</a>
				<a href="../campaigns/linreg.html">LinReg</a>
				<a href="../campaigns/multivars.html">MultiVars</a>
			</div>
		</li>
		<li class="dropdown active">
			<a href="javascript:void(0)" class="dropbtn">Common Scripts</a>
			<div class="dropdown-content">
				<a href="runcampaign.html">RunCampaign</a>
				<a href="createcampaign.html">CreateCampaign</a>
				<a href="activelearner.html">ActiveLearner</a>
				<a href="modeler.html">Modeler</a>
				<a href="database.html" class="active">Database</a>
				<a href="goaltether.html">Goal Tether</a>
				<a href="dataacquisition.html">Data Acquisition</a>
			</div>
		</li>
		<li><a href="../contributors.html">Contributors</a></li>
	</ul>

	<section id="introduction" class="content-start">
		<div class="container">
			<h2>About the Database object</h2>

			<p>The Database object defined in database.py is optimized to handle variety of datatypes for the BioActive software. The most basic functionalities include data storage and retrieval, but this can become rather complicated when multiple datatypes, experiments, and independent variables become involved. This python object has multiple options for the users to interact with, allowing them to treat is essentially as a black box. This documentation aims to guide the user to appropriately use the database object, while also giving a basic idea in what is happening under the hood.</p>
		</div>
	</section>

	<section id="initialization">
		<div class="container">
			<h2>Initialization</h2>

			<p>The following call will create appropriate temporary database and HDF5 file, a permanent storage option for archival, along with other auxilliary attributes to organize data. Note that there are lots of default values that can be modified by the user for variety of options. However, the basic dataflow structure is the same. The object is illustrated as below:</p>

			<pre><code class="language-py">DB = Database(dim_arr, filename, mode = 0, der = 0, dvars = 0, reset = False, sparse = True, ask = False, overwrite = True)</code></pre>

			<figure>
				<a href="images/init_1.jpg" target="_blank"><img src="images/init_1.jpg"></a>
				<figcaption>data structure of the database object after initialization</figcaption>
			</figure>

			<p>There are few things to note in the figure above. First, the nested objects within the database object compartmentalizes which object carries out which functionalities. The temporary database object is where the data is primarily stored while the program is running. This is to ensure the data storage and retrieval is fast and efficient while BioActive is running. The indexing object allows complex indexing system due to varieties of options that can be set by the user.</p>

			<p>Second, since the database object only exists in the RAM space, it has a pointer to the permanent storage space in the disc. The file format used for permanent storate is HDF5 (Hierarchial Data Format 5), an open source format used to efficiently store large amount of data. When a data is being transferred from the temporary space to the permanent space, the database object uses this pointer to appropriately locate the HDF5 file. Also note that when the database object is initialized, there aren't any information within the HDF5 file yet.</p>

			<h3>Initialization arguments</h3>

			<p>Aside from the "sparse" argument and "overwrite" arguments, the arguments doesn't fundamentally changes how data is organized.</p>

			<ul class="arguments">
				<li>
					<h4>dim_arr</h4>
					<p>input type: list of integers</p>
					<p>This argument specifies the dimensions formed by the independent variables. For instance, if there is an experimental space with 3 independent variables in which each the first indepdent variable has 5 elements, the second has 6, and the third has 7, dim_arr should be set as [5, 6, 7].</p>
				</li>

				<li>
					<h4>filename</h4>
					<p>input type: string</p>
					<p>This argument specifies the name of the HDF5 file that is generated by the initialization (without the .hdf5). If the file with the same name already exists, the database object will set the attribute flag = True, and use the same HDF5 file as the permanent storage space. This can potentially lead to previous data being overwritten or deleted if the arguments aren't set appropriately, so take caution.</p>
				</li>
				<li>
					<h4>mode</h4>
					<p>input type: int (0 or 1)</p>
					<p>default value: 0</p>
					<p>The storage of image into HDF5 needs special handling. In this implementation, I chose to convert the entire image file into binary and store that binary. To signal that the "raw data" from the experiment is image, this argument must be set to 1. In any other situations, mode must be set to 0.</p>
				</li>

				<li>
					<h4>reset</h4>
					<p>input type: boolean</p>
					<p>default value: False</p>
					<p>This argument provides an option for the user to start from clean slate. That being, if a user wants a specific name for the HDF5 file but wants to remove all previous data, this argument can be set to True, which will delete all previous data and start from blank when the database object is initialized.</p>
				</li>

				<li>
					<h4>ask</h4>
					<p>input type: boolean</p>
					<p>default value: False</p>
					<p>This argument allows the users to disregard the "filename" argument, and prompts the user to type in the name of the database to the terminal when the program runs, rather than hard-coding it into the script.</p>
				</li>
			</ul>

			<p>For the following arguments, it is important to note that the database object is implemented behind the principle that each datatype must be stored and called separately. For instance, let's say an experiment generates image. This will be considered "Raw Data". There are more data that can arise, such as feature vectors (type of tuple or array), name of the image file (string), or classification (int). It is not sensible to store all these different datatypes within the same array, for instance. Therefore, to give more meaning behind each datatypes and how they're related, the user is able to define the following attributes to allow for more datatypes.</p>

			<ul class="arguments">
				<li>
					<h4>der, dvars</h4>
					<p>input type: int (greater than or equal to 0)</p>
					<p>default value: 0</p>
					<p>As explained above, these arguments specify how many derived data or dependent variables the user wants. The space for "Raw Data" will always exist by default, but if the user intends to manipulate this raw data to get more from it and wants to store such data, these arguments must be set to different numbers. "der" sets the number of dervied data, and "dvars" sets the number of dependent variables. While they are organized in separate locations, the difference is merely of nomenclature.</p>
				</li>
			</ul>

			<p>The following two arguments changes the way in which data is organized within the database object. The "sparse" argument changes how the data is organized inside the temporary space, and the "overwrite" argument changes both temporary space and the permanent space.</p>

			<ul class="arguments">
				<li>
					<h4>sparse</h4>
					<p>input type: boolean</p>
					<p>default type: True</p>
					<p>This arguments decides which type of object to use for the temporary storage space. When set to True, the database object uses "TempDB_Sparse", which is a dictionary-based data storage object. When set to False, it uses "TempDB", which is an numpy array-based data storage object. TempDB_Sparse is more optimized for sparse-matrix experimental space in which not the majority of the experimental space is covered, while the opposite is true for TempDB.</p>
				</li>

				<li>
					<h4>overwrite</h4>
					<p>input type: boolean</p>
					<p>default type: True</p>
					<p>When this argument is True, data will be overwritten if a data point is fed into an experiment in which that experiment has been performed before. When this argument is False, the data will not be overwritten, but it will become an element of a growing list. In the temporary space, each experiemnt that holds a single data point turns into an array which can be appended with new data points. In the HDF5, the data organizational structure in overwrite=True is nested inside a group of "entry", which represents a sequential occurance of the experiment. Again, the database object is designed in a way that the user doesn't need to worry about this organizational structure.</p>

					<figure>
						<a href="images/overwrite.jpg" target="_blank"><img src="images/overwrite.jpg"></a>
						<figcaption>data organization within HDF5 when overwrite=True on the left and when overwrite=False on the right</figcaption>
					</figure>
				</li>
			</ul>

		</div>
	</section>

	<section id="storge">
		<div class="container">
			<h2>Data Storage</h2>

			<p>Data storage is one of the two most basic functionality of the Database object. The Database object must able to securely and reliably store the result of an experiment in the temporary space, and also in the permanent space. It must also consider how much storage space it takes up and how efficiently the data can be retrieved (space & time complexity). The storage function call must also be intutitive enough for the user to use without crashing the program.</p>

			<p>The function call for data storage is same as below:</p>

			<pre><code class="language-py">DB.store(arr, destination = "Raw Data")</code></pre>

			<p>The implementation details will be explained soon. Before, it is important to define some terminologies to explain the format of the input.</p>

			<p><strong>Datum</strong>: a single data which we intend to store. The current version supports int, float, string, tuple, list, numpy array, and images (in the form of string name).</p>

			<p><strong>Experiment</strong>: a combination of independent variables (i.e. (ivar1, ivar2, ..., ivarn)) that specifies the experiment condition.</p>

			<p><strong>Data point</strong>: a tuple in the form of (datum, ivar1, ivar2, ... ivarn). This specifies the data, and which experiment (combination of independent variables) is the datum acquired from.</p>

			<p>From this, we can explain the inputs to the store method:</p>

			<ul class="arguments">
				<li>
					<h4>arr</h4>
					<p>input type: list data points</p>
					<p>Each datapoint will be stored in the Database object at the specified experiment. Even if only single datapoint is to be stored, an array must be fed in as an input.</p>
				</li>

				<li>
					<h4>destination</h4>
					<p>input type: string</p>
					<p>default value: "Raw Data"</p>
					<p>Denotes which "detination" the data will be stored. Recall that datatype invariant holds within the same location, such as "Raw Data", "Dependent Variable x", and so on. This provides more meaning to the collection of the data. Acceptable arguments are "Raw Data", "Derived Data x", and "Dependent Variable y", given that 1 <= x <= der and 1 <= y <= dvars from initialization. This also means that within the arr argument, all datum in the array must be of the same type.</p>
				</li>
			</ul>

			<p>Once the user calls the Database object to store some data, the data is first stored inside the temporary RAM space. This implementation detail was chosen due to relatively fast retrieval time compared to storing the data directly into the disc. The data will remain in the temporary space until the program terminates.</p>

			<figure>
				<a href="images/store_1.jpg" target="_blank"><img src="images/store_1.jpg"></a>
				<a href="images/store_2.jpg" target="_blank"><img src="images/store_2.jpg"></a>
				<figcaption>Calling store method and data being moved to temporary database object; store_ind is called to indexing object</figcaption>
			</figure>
			
			<p>This raises the question, "when does the data actually gets to be stored in the disc space?". To do so, we must first create the space within the HDF5 file so that the data can stay there. Remember that there's a great emphasis on "datatype invariant" in Database object. Once the user decides, say "I would like to store all feature vectors as a derived data", all feature vectors should be stored at a location "Derived Data 1", and only feature vectors should be stored there; it wouldn't make sense to store string inside "Derived Data 1". This is what the "destination" argument and "location" argument (that will be introduced later) represents; within the same destination or location, datatype invariant must hold.</p>

			<p>In HDF5, all data is stored in "datasets". Complicated HDF5 implementation details aside, the only important detail is that it is very economic in storing large amount of data, and can support lots of dimensions (represented by independent variables). This is analogous to n-dimensional matrix in theoretical level. The catch is, all elements in a single dataset must be of same datatype, which corresponds to Database's datatype invariant requirement. Thus, the datatype of the dataset must be specified when it is initialized. This is too much to specify for a user, so the Database object internally identifies the datatype of the first input at a specific location, and initializes the dataset within the HDF5. Note that simply initializing the dataset takes minial storage space thanks to HDF5's clever implementation (location within the disc is allocated in sequential manner as the data is stored, so initializing a dataset that can potentially hold TB of data can only be few kB when initialized). The user is expected to store datum with the same type in every following store call. This detail has been omitted in the image above, so to show in more detail what happens in the data structure refer to below:</p>

			<figure>
				<a href="images/store_3.jpg" target="_blank"><img src="images/store_3.jpg"></a>
				<a href="images/store_4.jpg" target="_blank"><img src="images/store_4.jpg"></a>
				<figcaption>Datatype is recognized by an internal call dtype_extraction and is stored at dtypes attribute, and makenewdset is called to initialize a dataset in HDF5.</figcaption>
			</figure>

			<p>Once the data is present in the temporary space and dataset in HDF5 initialized, storing to the permanent disc space is merely copying the data from the temporary database object and moving it to the permanent space. The location and the experiment is already specified, so no additional information is required. This is a rather expensive operation, however, due to the nature of accessing disc space. Think about this operation as the "save" button. Note that data is not removed from the temporary space to ensure quick access by the program. Once the data is flushed, it will not be flushed again since the temporary database object remembers which datum has been flushed or not. The function call takes in no arguments, and the visual representation is shown below:</p>

			<pre><code class="language-py">DB.flush()</code></pre>

			<figure>
				<a href="images/store_5.jpg" target="_blank"><img src="images/store_5.jpg"></a>
				<a href="images/store_6.jpg" target="_blank"><img src="images/store_6.jpg"></a>
				<figcaption>flush call copies data from the temporary space to the permanent space</figcaption>
			</figure>

		</div>
	</section>

	<section id="retrieval">
		<div class="container">
			<h2>Data Retrieval</h2>

			<p>Retrieval is a rather straight forward process. It is simply looking the datum or a group of datum at the appropriate place and returning it. There are multitudes of options, however, to accomodate for various situation. The argument "flag" controls the majority of retrieval option. The basic implementation idea is still rather simple.</p>

			<pre><code class="language-py">DB.retrieve(getfrom, location = "Raw Data", archived = False, flag = "one", entry = -1)</code></pre>

			<ul class="arguments">
				<li>
					<h4>location</h4>
					<p>input type: string</p>
					<p>default value: "Raw Data"</p>
					<p>denotes where the data must be retrieved from. This is analogous to "destination" argument in storage function.</p>
				</li>

				<li>
					<h4>archived</h4>
					<p>input type: boolean</p>
					<p>default value: False</p>
					<p>denotes the physical space in which the data should be retrieved. If true, data will be retrieved from HDF5. If false, data will be retrieved from the temporary database object.</p>
				</li>

				<li>
					<h4>flag</h4>
					<p>input type: string</p>
					<p>default value: "one"</p>
					<p>Denotes different "versions of retrieval. The options and their explanations are listed below:</p>
					<p><strong>"one"</strong>: denotes to retrieve one datum. The type of the data retrieved will be the type of datum of the location we're retrieving from. If overwrite is set to False during initialization, one datum is defined to be an array of all datum for that experiment.</p>
					<p><strong>"arr"</strong>: denotes to retrieve all experiments of the given input array. Since there are multiple datum being retrieved, the return type has to denote where each datum is retrieved from. Therefre, the return type is a list of data point, similar to the input to storage function.</p>
					<p><strong>"all"</strong>: denotes to retrieva all data that we've observed. Return type is same as "arr" flag - a list of data point.</p>
					<p><strong>"ivar"</strong>: denotes to retrieve all data related to a specific element of a specific independent variable.</p>
					<p><strong>"entry"</strong>: denotes to retrieve all data of the specified experiment as a tuble (Raw Data, Derived Data, and Dependent Variable in that order)</p>
				</li>

				<li>
					<h4>getfrom</h4>
					<p>input type: vary</p>
					<p>abstractly, this argument represents where the data should be retrieved from; this can be an experiment specification or other argument, depending on the flag. The input specification depending on each flag is listed below:</p>
					<p><strong>"one"</strong>: a tuple of independent variables that specifies a single experiment.</p>
					<p><strong>"arr"</strong>: a list of experiments (tuples specifying a single experiment).</p>
					<p><strong>"all"</strong>: no input is needed, but getfrom argument still needs to be specified as something (anything is acceptable)</p>
					<p><strong>"ivar"</strong>: a tuple of two integers such that the first element represents the index of independent variable among all independent variables, and the second element represents the index of an element among all elements in that specific independent variable.</p>
					<p><strong>"entry"</strong>: same type as flag "one", but the return type will be a tuple of all datum related to that experiment.</p>
				</li>

				<li>
					<h4>entry</h4>
					<p>input type: int</p>
					<p>default value: -1</p>
					<p>This argument should be manipulated only if overwrite argument is set to False during initialization. If overwrite is false, the "datum" is an array with all entries of that experiment. If a user wants to retrieve a specific entry of the experiment, this argument must be set to that entry number. Note that this is not 0-indexed, as in the HDF5, the entry is organized starting from 1.</p>
				</li>
			</ul>

			<p>Note that the return type can vary depending on the combination of the arguments. It is the responsibility of the user to understand the output format and mainipulate it appropriately to use it. A visual representation of data retrieval is shown as below:</p>

			<figure>
				<a href="images/retrieve_1.jpg" target="_blank"><img src="images/retrieve_1.jpg"></a>
				<a href="images/retrieve_2.jpg" target="_blank"><img src="images/retrieve_2.jpg"></a>
				<figcaption>Retrieve call copies the data within the Database object and returns it to the user.</figcaption>
			</figure>
		</div>
	</section>

	<script src="../main.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js"></script>
</body>
</html>